{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport DeviceEventEmitter from \"react-native-web/dist/exports/DeviceEventEmitter\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport KeyboardAvoidingView from \"react-native-web/dist/exports/KeyboardAvoidingView\";\nimport Modal from \"react-native-web/dist/exports/Modal\";\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport TouchableWithoutFeedback from \"react-native-web/dist/exports/TouchableWithoutFeedback\";\nimport View from \"react-native-web/dist/exports/View\";\nimport * as PropTypes from 'prop-types';\nimport * as animatable from 'react-native-animatable';\nimport { initializeAnimations, buildAnimations, reversePercentage } from \"./utils\";\nimport styles from \"./modal.style\";\ninitializeAnimations();\n\nvar extractAnimationFromProps = function extractAnimationFromProps(props) {\n  return {\n    animationIn: props.animationIn,\n    animationOut: props.animationOut\n  };\n};\n\nexport var ReactNativeModal = function (_React$Component) {\n  _inherits(ReactNativeModal, _React$Component);\n\n  function ReactNativeModal(props) {\n    var _this;\n\n    _classCallCheck(this, ReactNativeModal);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ReactNativeModal).call(this, props));\n    _this.state = {\n      showContent: true,\n      isVisible: false,\n      deviceWidth: Dimensions.get('screen').width,\n      deviceHeight: Dimensions.get('screen').height,\n      isSwipeable: _this.props.swipeDirection ? true : false,\n      pan: null\n    };\n    _this.isTransitioning = false;\n    _this.inSwipeClosingState = false;\n    _this.currentSwipingDirection = null;\n    _this.panResponder = null;\n\n    _this.buildPanResponder = function () {\n      var animEvt = null;\n      _this.panResponder = PanResponder.create({\n        onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(evt, gestureState) {\n          if (!_this.props.propagateSwipe) {\n            var shouldSetPanResponder = Math.abs(gestureState.dx) >= 4 || Math.abs(gestureState.dy) >= 4;\n\n            if (shouldSetPanResponder && _this.props.onSwipeStart) {\n              _this.props.onSwipeStart();\n            }\n\n            _this.currentSwipingDirection = _this.getSwipingDirection(gestureState);\n            animEvt = _this.createAnimationEventForSwipe();\n            return shouldSetPanResponder;\n          }\n\n          return false;\n        },\n        onStartShouldSetPanResponder: function onStartShouldSetPanResponder() {\n          if (_this.props.scrollTo && _this.props.scrollOffset > 0) {\n            return false;\n          }\n\n          if (_this.props.onSwipeStart) {\n            _this.props.onSwipeStart();\n          }\n\n          _this.currentSwipingDirection = null;\n          return true;\n        },\n        onPanResponderMove: function onPanResponderMove(evt, gestureState) {\n          if (!_this.currentSwipingDirection) {\n            if (gestureState.dx === 0 && gestureState.dy === 0) {\n              return;\n            }\n\n            _this.currentSwipingDirection = _this.getSwipingDirection(gestureState);\n            animEvt = _this.createAnimationEventForSwipe();\n          }\n\n          if (_this.isSwipeDirectionAllowed(gestureState)) {\n            var newOpacityFactor = 1 - _this.calcDistancePercentage(gestureState);\n\n            _this.backdropRef && _this.backdropRef.transitionTo({\n              opacity: _this.props.backdropOpacity * newOpacityFactor\n            });\n            animEvt(evt, gestureState);\n\n            if (_this.props.onSwipeMove) {\n              _this.props.onSwipeMove(newOpacityFactor);\n            }\n          } else {\n            if (_this.props.scrollTo) {\n              if (_this.props.scrollHorizontal) {\n                var offsetX = -gestureState.dx;\n\n                if (offsetX > _this.props.scrollOffsetMax) {\n                  offsetX -= (offsetX - _this.props.scrollOffsetMax) / 2;\n                }\n\n                _this.props.scrollTo({\n                  x: offsetX,\n                  animated: false\n                });\n              } else {\n                var offsetY = -gestureState.dy;\n\n                if (offsetY > _this.props.scrollOffsetMax) {\n                  offsetY -= (offsetY - _this.props.scrollOffsetMax) / 2;\n                }\n\n                _this.props.scrollTo({\n                  y: offsetY,\n                  animated: false\n                });\n              }\n            }\n          }\n        },\n        onPanResponderRelease: function onPanResponderRelease(evt, gestureState) {\n          var accDistance = _this.getAccDistancePerDirection(gestureState);\n\n          if (accDistance > _this.props.swipeThreshold && _this.isSwipeDirectionAllowed(gestureState)) {\n            if (_this.props.onSwipeComplete) {\n              _this.inSwipeClosingState = true;\n\n              _this.props.onSwipeComplete({\n                swipingDirection: _this.getSwipingDirection(gestureState)\n              });\n\n              return;\n            }\n\n            if (_this.props.onSwipe) {\n              _this.inSwipeClosingState = true;\n\n              _this.props.onSwipe();\n\n              return;\n            }\n          }\n\n          if (_this.props.onSwipeCancel) {\n            _this.props.onSwipeCancel();\n          }\n\n          if (_this.backdropRef) {\n            _this.backdropRef.transitionTo({\n              opacity: _this.props.backdropOpacity\n            });\n          }\n\n          Animated.spring(_this.state.pan, {\n            toValue: {\n              x: 0,\n              y: 0\n            },\n            bounciness: 0,\n            useNativeDriver: false\n          }).start();\n\n          if (_this.props.scrollTo) {\n            if (_this.props.scrollOffset > _this.props.scrollOffsetMax) {\n              _this.props.scrollTo({\n                y: _this.props.scrollOffsetMax,\n                animated: true\n              });\n            }\n          }\n        }\n      });\n    };\n\n    _this.getAccDistancePerDirection = function (gestureState) {\n      switch (_this.currentSwipingDirection) {\n        case 'up':\n          return -gestureState.dy;\n\n        case 'down':\n          return gestureState.dy;\n\n        case 'right':\n          return gestureState.dx;\n\n        case 'left':\n          return -gestureState.dx;\n\n        default:\n          return 0;\n      }\n    };\n\n    _this.getSwipingDirection = function (gestureState) {\n      if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy)) {\n        return gestureState.dx > 0 ? 'right' : 'left';\n      }\n\n      return gestureState.dy > 0 ? 'down' : 'up';\n    };\n\n    _this.calcDistancePercentage = function (gestureState) {\n      switch (_this.currentSwipingDirection) {\n        case 'down':\n          return (gestureState.moveY - gestureState.y0) / ((_this.props.deviceHeight || _this.state.deviceHeight) - gestureState.y0);\n\n        case 'up':\n          return reversePercentage(gestureState.moveY / gestureState.y0);\n\n        case 'left':\n          return reversePercentage(gestureState.moveX / gestureState.x0);\n\n        case 'right':\n          return (gestureState.moveX - gestureState.x0) / ((_this.props.deviceWidth || _this.state.deviceWidth) - gestureState.x0);\n\n        default:\n          return 0;\n      }\n    };\n\n    _this.createAnimationEventForSwipe = function () {\n      if (_this.currentSwipingDirection === 'right' || _this.currentSwipingDirection === 'left') {\n        return Animated.event([null, {\n          dx: _this.state.pan.x\n        }], {\n          useNativeDriver: false\n        });\n      } else {\n        return Animated.event([null, {\n          dy: _this.state.pan.y\n        }], {\n          useNativeDriver: false\n        });\n      }\n    };\n\n    _this.isDirectionIncluded = function (direction) {\n      return Array.isArray(_this.props.swipeDirection) ? _this.props.swipeDirection.includes(direction) : _this.props.swipeDirection === direction;\n    };\n\n    _this.isSwipeDirectionAllowed = function (_ref) {\n      var dy = _ref.dy,\n          dx = _ref.dx;\n      var draggedDown = dy > 0;\n      var draggedUp = dy < 0;\n      var draggedLeft = dx < 0;\n      var draggedRight = dx > 0;\n\n      if (_this.currentSwipingDirection === 'up' && _this.isDirectionIncluded('up') && draggedUp) {\n        return true;\n      } else if (_this.currentSwipingDirection === 'down' && _this.isDirectionIncluded('down') && draggedDown) {\n        return true;\n      } else if (_this.currentSwipingDirection === 'right' && _this.isDirectionIncluded('right') && draggedRight) {\n        return true;\n      } else if (_this.currentSwipingDirection === 'left' && _this.isDirectionIncluded('left') && draggedLeft) {\n        return true;\n      }\n\n      return false;\n    };\n\n    _this.handleDimensionsUpdate = function () {\n      if (!_this.props.deviceHeight && !_this.props.deviceWidth) {\n        var deviceWidth = Dimensions.get('screen').width;\n        var deviceHeight = Dimensions.get('screen').height;\n\n        if (deviceWidth !== _this.state.deviceWidth || deviceHeight !== _this.state.deviceHeight) {\n          _this.setState({\n            deviceWidth: deviceWidth,\n            deviceHeight: deviceHeight\n          });\n        }\n      }\n    };\n\n    _this.open = function () {\n      if (_this.isTransitioning) {\n        return;\n      }\n\n      _this.isTransitioning = true;\n\n      if (_this.backdropRef) {\n        _this.backdropRef.transitionTo({\n          opacity: _this.props.backdropOpacity\n        }, _this.props.backdropTransitionInTiming);\n      }\n\n      if (_this.state.isSwipeable) {\n        _this.state.pan.setValue({\n          x: 0,\n          y: 0\n        });\n      }\n\n      if (_this.contentRef) {\n        _this.props.onModalWillShow && _this.props.onModalWillShow();\n\n        _this.contentRef.animate(_this.animationIn, _this.props.animationInTiming).then(function () {\n          _this.isTransitioning = false;\n\n          if (!_this.props.isVisible) {\n            _this.close();\n          } else {\n            _this.props.onModalShow();\n          }\n        });\n      }\n    };\n\n    _this.close = function () {\n      if (_this.isTransitioning) {\n        return;\n      }\n\n      _this.isTransitioning = true;\n\n      if (_this.backdropRef) {\n        _this.backdropRef.transitionTo({\n          opacity: 0\n        }, _this.props.backdropTransitionOutTiming);\n      }\n\n      var animationOut = _this.animationOut;\n\n      if (_this.inSwipeClosingState) {\n        _this.inSwipeClosingState = false;\n\n        if (_this.currentSwipingDirection === 'up') {\n          animationOut = 'slideOutUp';\n        } else if (_this.currentSwipingDirection === 'down') {\n          animationOut = 'slideOutDown';\n        } else if (_this.currentSwipingDirection === 'right') {\n          animationOut = 'slideOutRight';\n        } else if (_this.currentSwipingDirection === 'left') {\n          animationOut = 'slideOutLeft';\n        }\n      }\n\n      if (_this.contentRef) {\n        _this.props.onModalWillHide && _this.props.onModalWillHide();\n\n        _this.contentRef.animate(animationOut, _this.props.animationOutTiming).then(function () {\n          _this.isTransitioning = false;\n\n          if (_this.props.isVisible) {\n            _this.open();\n          } else {\n            _this.setState({\n              showContent: false\n            }, function () {\n              _this.setState({\n                isVisible: false\n              }, function () {\n                _this.props.onModalHide();\n              });\n            });\n          }\n        });\n      }\n    };\n\n    var _buildAnimations = buildAnimations(extractAnimationFromProps(props)),\n        animationIn = _buildAnimations.animationIn,\n        animationOut = _buildAnimations.animationOut;\n\n    _this.animationIn = animationIn;\n    _this.animationOut = animationOut;\n\n    if (_this.state.isSwipeable) {\n      _this.state = _objectSpread({}, _this.state, {\n        pan: new Animated.ValueXY()\n      });\n\n      _this.buildPanResponder();\n    }\n\n    if (props.isVisible) {\n      _this.state = _objectSpread({}, _this.state, {\n        isVisible: true,\n        showContent: true\n      });\n    }\n\n    return _this;\n  }\n\n  _createClass(ReactNativeModal, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.onSwipe) {\n        console.warn('`<Modal onSwipe=\"...\" />` is deprecated and will be removed starting from 13.0.0. Use `<Modal onSwipeComplete=\"...\" />` instead.');\n      }\n\n      DeviceEventEmitter.addListener('didUpdateDimensions', this.handleDimensionsUpdate);\n\n      if (this.state.isVisible) {\n        this.open();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      DeviceEventEmitter.removeListener('didUpdateDimensions', this.handleDimensionsUpdate);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.props.animationIn !== prevProps.animationIn || this.props.animationOut !== prevProps.animationOut) {\n        var _buildAnimations2 = buildAnimations(extractAnimationFromProps(this.props)),\n            animationIn = _buildAnimations2.animationIn,\n            animationOut = _buildAnimations2.animationOut;\n\n        this.animationIn = animationIn;\n        this.animationOut = animationOut;\n      }\n\n      if (this.props.backdropOpacity !== prevProps.backdropOpacity && this.backdropRef) {\n        this.backdropRef.transitionTo({\n          opacity: this.props.backdropOpacity\n        }, this.props.backdropTransitionInTiming);\n      }\n\n      if (this.props.isVisible && !prevProps.isVisible) {\n        this.open();\n      } else if (!this.props.isVisible && prevProps.isVisible) {\n        this.close();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          animationIn = _this$props.animationIn,\n          animationInTiming = _this$props.animationInTiming,\n          animationOut = _this$props.animationOut,\n          animationOutTiming = _this$props.animationOutTiming,\n          avoidKeyboard = _this$props.avoidKeyboard,\n          coverScreen = _this$props.coverScreen,\n          hasBackdrop = _this$props.hasBackdrop,\n          backdropColor = _this$props.backdropColor,\n          backdropOpacity = _this$props.backdropOpacity,\n          backdropTransitionInTiming = _this$props.backdropTransitionInTiming,\n          backdropTransitionOutTiming = _this$props.backdropTransitionOutTiming,\n          customBackdrop = _this$props.customBackdrop,\n          children = _this$props.children,\n          deviceHeightProp = _this$props.deviceHeight,\n          deviceWidthProp = _this$props.deviceWidth,\n          isVisible = _this$props.isVisible,\n          onModalShow = _this$props.onModalShow,\n          onBackdropPress = _this$props.onBackdropPress,\n          onBackButtonPress = _this$props.onBackButtonPress,\n          useNativeDriver = _this$props.useNativeDriver,\n          propagateSwipe = _this$props.propagateSwipe,\n          style = _this$props.style,\n          otherProps = _objectWithoutProperties(_this$props, [\"animationIn\", \"animationInTiming\", \"animationOut\", \"animationOutTiming\", \"avoidKeyboard\", \"coverScreen\", \"hasBackdrop\", \"backdropColor\", \"backdropOpacity\", \"backdropTransitionInTiming\", \"backdropTransitionOutTiming\", \"customBackdrop\", \"children\", \"deviceHeight\", \"deviceWidth\", \"isVisible\", \"onModalShow\", \"onBackdropPress\", \"onBackButtonPress\", \"useNativeDriver\", \"propagateSwipe\", \"style\"]);\n\n      var deviceWidth = deviceWidthProp || this.state.deviceWidth;\n      var deviceHeight = deviceHeightProp || this.state.deviceHeight;\n      var computedStyle = [{\n        margin: deviceWidth * 0.05,\n        transform: [{\n          translateY: 0\n        }]\n      }, styles.content, style];\n      var panHandlers = {};\n      var panPosition = {};\n\n      if (this.state.isSwipeable) {\n        panHandlers = _objectSpread({}, this.panResponder.panHandlers);\n\n        if (useNativeDriver) {\n          panPosition = {\n            transform: this.state.pan.getTranslateTransform()\n          };\n        } else {\n          panPosition = this.state.pan.getLayout();\n        }\n      }\n\n      var _children = this.props.hideModalContentWhileAnimating && this.props.useNativeDriver && !this.state.showContent ? React.createElement(animatable.View, null) : children;\n\n      var containerView = React.createElement(animatable.View, _extends({}, panHandlers, {\n        ref: function ref(_ref2) {\n          return _this2.contentRef = _ref2;\n        },\n        style: [panPosition, computedStyle],\n        pointerEvents: \"box-none\",\n        useNativeDriver: useNativeDriver\n      }, otherProps), _children);\n      var hasCustomBackdrop = React.isValidElement(customBackdrop);\n      var backdropComputedStyle = [{\n        width: deviceWidth,\n        height: deviceHeight,\n        backgroundColor: this.state.showContent && !hasCustomBackdrop ? backdropColor : 'transparent'\n      }];\n      var backdropContent = React.createElement(animatable.View, {\n        ref: function ref(_ref3) {\n          return _this2.backdropRef = _ref3;\n        },\n        useNativeDriver: useNativeDriver,\n        style: [styles.backdrop, backdropComputedStyle]\n      }, hasCustomBackdrop && customBackdrop);\n      var backdrop = null;\n\n      if (hasCustomBackdrop) {\n        backdrop = backdropContent;\n      } else {\n        backdrop = React.createElement(TouchableWithoutFeedback, {\n          onPress: onBackdropPress\n        }, backdropContent);\n      }\n\n      if (!coverScreen && this.state.isVisible) {\n        return React.createElement(View, {\n          pointerEvents: \"box-none\",\n          style: [styles.backdrop, styles.containerBox]\n        }, hasBackdrop && backdrop, containerView);\n      }\n\n      return React.createElement(Modal, _extends({\n        transparent: true,\n        animationType: 'none',\n        visible: this.state.isVisible,\n        onRequestClose: onBackButtonPress\n      }, otherProps), hasBackdrop && backdrop, avoidKeyboard && React.createElement(KeyboardAvoidingView, {\n        behavior: Platform.OS === 'ios' ? 'padding' : undefined,\n        pointerEvents: \"box-none\",\n        style: computedStyle.concat([{\n          margin: 0\n        }])\n      }, containerView), !avoidKeyboard && containerView);\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, state) {\n      if (!state.isVisible && nextProps.isVisible) {\n        return {\n          isVisible: true,\n          showContent: true\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return ReactNativeModal;\n}(React.Component);\nReactNativeModal.propTypes = {\n  animationIn: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  animationInTiming: PropTypes.number,\n  animationOut: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  animationOutTiming: PropTypes.number,\n  avoidKeyboard: PropTypes.bool,\n  coverScreen: PropTypes.bool,\n  hasBackdrop: PropTypes.bool,\n  backdropColor: PropTypes.string,\n  backdropOpacity: PropTypes.number,\n  backdropTransitionInTiming: PropTypes.number,\n  backdropTransitionOutTiming: PropTypes.number,\n  customBackdrop: PropTypes.node,\n  children: PropTypes.node.isRequired,\n  deviceHeight: PropTypes.number,\n  deviceWidth: PropTypes.number,\n  isVisible: PropTypes.bool.isRequired,\n  hideModalContentWhileAnimating: PropTypes.bool,\n  propagateSwipe: PropTypes.bool,\n  onModalShow: PropTypes.func,\n  onModalWillShow: PropTypes.func,\n  onModalHide: PropTypes.func,\n  onModalWillHide: PropTypes.func,\n  onBackButtonPress: PropTypes.func,\n  onBackdropPress: PropTypes.func,\n  onSwipeStart: PropTypes.func,\n  onSwipeMove: PropTypes.func,\n  onSwipeComplete: PropTypes.func,\n  onSwipeCancel: PropTypes.func,\n  swipeThreshold: PropTypes.number,\n  swipeDirection: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOf(['up', 'down', 'left', 'right'])), PropTypes.oneOf(['up', 'down', 'left', 'right'])]),\n  useNativeDriver: PropTypes.bool,\n  style: PropTypes.any,\n  scrollTo: PropTypes.func,\n  scrollOffset: PropTypes.number,\n  scrollOffsetMax: PropTypes.number,\n  scrollHorizontal: PropTypes.bool,\n  supportedOrientations: PropTypes.arrayOf(PropTypes.oneOf(['portrait', 'portrait-upside-down', 'landscape', 'landscape-left', 'landscape-right']))\n};\nReactNativeModal.defaultProps = {\n  animationIn: 'slideInUp',\n  animationInTiming: 300,\n  animationOut: 'slideOutDown',\n  animationOutTiming: 300,\n  avoidKeyboard: false,\n  coverScreen: true,\n  hasBackdrop: true,\n  backdropColor: 'black',\n  backdropOpacity: 0.7,\n  backdropTransitionInTiming: 300,\n  backdropTransitionOutTiming: 300,\n  customBackdrop: null,\n  useNativeDriver: false,\n  deviceHeight: null,\n  deviceWidth: null,\n  hideModalContentWhileAnimating: false,\n  propagateSwipe: false,\n  isVisible: false,\n  onModalShow: function onModalShow() {\n    return null;\n  },\n  onModalWillShow: function onModalWillShow() {\n    return null;\n  },\n  onModalHide: function onModalHide() {\n    return null;\n  },\n  onModalWillHide: function onModalWillHide() {\n    return null;\n  },\n  onBackdropPress: function onBackdropPress() {\n    return null;\n  },\n  onBackButtonPress: function onBackButtonPress() {\n    return null;\n  },\n  swipeThreshold: 100,\n  scrollTo: null,\n  scrollOffset: 0,\n  scrollOffsetMax: 0,\n  scrollHorizontal: false,\n  supportedOrientations: ['portrait', 'landscape']\n};\nexport default ReactNativeModal;","map":{"version":3,"sources":["/home/quyetnguyen/node_modules/react-native-modal/dist/modal.js"],"names":["React","PropTypes","animatable","initializeAnimations","buildAnimations","reversePercentage","styles","extractAnimationFromProps","props","animationIn","animationOut","ReactNativeModal","state","showContent","isVisible","deviceWidth","Dimensions","get","width","deviceHeight","height","isSwipeable","swipeDirection","pan","isTransitioning","inSwipeClosingState","currentSwipingDirection","panResponder","buildPanResponder","animEvt","PanResponder","create","onMoveShouldSetPanResponder","evt","gestureState","propagateSwipe","shouldSetPanResponder","Math","abs","dx","dy","onSwipeStart","getSwipingDirection","createAnimationEventForSwipe","onStartShouldSetPanResponder","scrollTo","scrollOffset","onPanResponderMove","isSwipeDirectionAllowed","newOpacityFactor","calcDistancePercentage","backdropRef","transitionTo","opacity","backdropOpacity","onSwipeMove","scrollHorizontal","offsetX","scrollOffsetMax","x","animated","offsetY","y","onPanResponderRelease","accDistance","getAccDistancePerDirection","swipeThreshold","onSwipeComplete","swipingDirection","onSwipe","onSwipeCancel","Animated","spring","toValue","bounciness","useNativeDriver","start","moveY","y0","moveX","x0","event","isDirectionIncluded","direction","Array","isArray","includes","draggedDown","draggedUp","draggedLeft","draggedRight","handleDimensionsUpdate","setState","open","backdropTransitionInTiming","setValue","contentRef","onModalWillShow","animate","animationInTiming","then","close","onModalShow","backdropTransitionOutTiming","onModalWillHide","animationOutTiming","onModalHide","ValueXY","console","warn","DeviceEventEmitter","addListener","removeListener","prevProps","avoidKeyboard","coverScreen","hasBackdrop","backdropColor","customBackdrop","children","deviceHeightProp","deviceWidthProp","onBackdropPress","onBackButtonPress","style","otherProps","computedStyle","margin","transform","translateY","content","panHandlers","panPosition","getTranslateTransform","getLayout","_children","hideModalContentWhileAnimating","createElement","View","containerView","ref","pointerEvents","hasCustomBackdrop","isValidElement","backdropComputedStyle","backgroundColor","backdropContent","backdrop","TouchableWithoutFeedback","onPress","containerBox","Modal","transparent","animationType","visible","onRequestClose","KeyboardAvoidingView","behavior","Platform","OS","undefined","concat","nextProps","Component","propTypes","oneOfType","string","object","number","bool","node","isRequired","func","arrayOf","oneOf","any","supportedOrientations","defaultProps"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { Animated, DeviceEventEmitter, Dimensions, KeyboardAvoidingView, Modal, PanResponder, Platform, TouchableWithoutFeedback, View, } from 'react-native';\nimport * as PropTypes from 'prop-types';\nimport * as animatable from 'react-native-animatable';\nimport { initializeAnimations, buildAnimations, reversePercentage, } from './utils';\nimport styles from './modal.style';\n// Override default react-native-animatable animations\ninitializeAnimations();\nconst extractAnimationFromProps = (props) => ({\n    animationIn: props.animationIn,\n    animationOut: props.animationOut,\n});\nexport class ReactNativeModal extends React.Component {\n    constructor(props) {\n        super(props);\n        // We use an internal state for keeping track of the modal visibility: this allows us to keep\n        // the modal visible during the exit animation, even if the user has already change the\n        // isVisible prop to false.\n        // We store in the state the device width and height so that we can update the modal on\n        // device rotation.\n        this.state = {\n            showContent: true,\n            isVisible: false,\n            deviceWidth: Dimensions.get('screen').width,\n            deviceHeight: Dimensions.get('screen').height,\n            isSwipeable: this.props.swipeDirection ? true : false,\n            pan: null,\n        };\n        this.isTransitioning = false;\n        this.inSwipeClosingState = false;\n        this.currentSwipingDirection = null;\n        this.panResponder = null;\n        this.buildPanResponder = () => {\n            let animEvt = null;\n            this.panResponder = PanResponder.create({\n                onMoveShouldSetPanResponder: (evt, gestureState) => {\n                    // Use propagateSwipe to allow inner content to scroll. See PR:\n                    // https://github.com/react-native-community/react-native-modal/pull/246\n                    if (!this.props.propagateSwipe) {\n                        // The number \"4\" is just a good tradeoff to make the panResponder\n                        // work correctly even when the modal has touchable buttons.\n                        // For reference:\n                        // https://github.com/react-native-community/react-native-modal/pull/197\n                        const shouldSetPanResponder = Math.abs(gestureState.dx) >= 4 || Math.abs(gestureState.dy) >= 4;\n                        if (shouldSetPanResponder && this.props.onSwipeStart) {\n                            this.props.onSwipeStart();\n                        }\n                        this.currentSwipingDirection = this.getSwipingDirection(gestureState);\n                        animEvt = this.createAnimationEventForSwipe();\n                        return shouldSetPanResponder;\n                    }\n                    return false;\n                },\n                onStartShouldSetPanResponder: () => {\n                    if (this.props.scrollTo && this.props.scrollOffset > 0) {\n                        return false; // user needs to be able to scroll content back up\n                    }\n                    if (this.props.onSwipeStart) {\n                        this.props.onSwipeStart();\n                    }\n                    // Cleared so that onPanResponderMove can wait to have some delta\n                    // to work with\n                    this.currentSwipingDirection = null;\n                    return true;\n                },\n                onPanResponderMove: (evt, gestureState) => {\n                    // Using onStartShouldSetPanResponder we don't have any delta so we don't know\n                    // The direction to which the user is swiping until some move have been done\n                    if (!this.currentSwipingDirection) {\n                        if (gestureState.dx === 0 && gestureState.dy === 0) {\n                            return;\n                        }\n                        this.currentSwipingDirection = this.getSwipingDirection(gestureState);\n                        animEvt = this.createAnimationEventForSwipe();\n                    }\n                    if (this.isSwipeDirectionAllowed(gestureState)) {\n                        // Dim the background while swiping the modal\n                        const newOpacityFactor = 1 - this.calcDistancePercentage(gestureState);\n                        this.backdropRef &&\n                            this.backdropRef.transitionTo({\n                                opacity: this.props.backdropOpacity * newOpacityFactor,\n                            });\n                        animEvt(evt, gestureState);\n                        if (this.props.onSwipeMove) {\n                            this.props.onSwipeMove(newOpacityFactor);\n                        }\n                    }\n                    else {\n                        if (this.props.scrollTo) {\n                            if (this.props.scrollHorizontal) {\n                                let offsetX = -gestureState.dx;\n                                if (offsetX > this.props.scrollOffsetMax) {\n                                    offsetX -= (offsetX - this.props.scrollOffsetMax) / 2;\n                                }\n                                this.props.scrollTo({ x: offsetX, animated: false });\n                            }\n                            else {\n                                let offsetY = -gestureState.dy;\n                                if (offsetY > this.props.scrollOffsetMax) {\n                                    offsetY -= (offsetY - this.props.scrollOffsetMax) / 2;\n                                }\n                                this.props.scrollTo({ y: offsetY, animated: false });\n                            }\n                        }\n                    }\n                },\n                onPanResponderRelease: (evt, gestureState) => {\n                    // Call the onSwipe prop if the threshold has been exceeded on the right direction\n                    const accDistance = this.getAccDistancePerDirection(gestureState);\n                    if (accDistance > this.props.swipeThreshold &&\n                        this.isSwipeDirectionAllowed(gestureState)) {\n                        if (this.props.onSwipeComplete) {\n                            this.inSwipeClosingState = true;\n                            this.props.onSwipeComplete({\n                                swipingDirection: this.getSwipingDirection(gestureState),\n                            });\n                            return;\n                        }\n                        // Deprecated. Remove later.\n                        if (this.props.onSwipe) {\n                            this.inSwipeClosingState = true;\n                            this.props.onSwipe();\n                            return;\n                        }\n                    }\n                    //Reset backdrop opacity and modal position\n                    if (this.props.onSwipeCancel) {\n                        this.props.onSwipeCancel();\n                    }\n                    if (this.backdropRef) {\n                        this.backdropRef.transitionTo({\n                            opacity: this.props.backdropOpacity,\n                        });\n                    }\n                    Animated.spring(this.state.pan, {\n                        toValue: { x: 0, y: 0 },\n                        bounciness: 0,\n                        useNativeDriver: false,\n                    }).start();\n                    if (this.props.scrollTo) {\n                        if (this.props.scrollOffset > this.props.scrollOffsetMax) {\n                            this.props.scrollTo({\n                                y: this.props.scrollOffsetMax,\n                                animated: true,\n                            });\n                        }\n                    }\n                },\n            });\n        };\n        this.getAccDistancePerDirection = (gestureState) => {\n            switch (this.currentSwipingDirection) {\n                case 'up':\n                    return -gestureState.dy;\n                case 'down':\n                    return gestureState.dy;\n                case 'right':\n                    return gestureState.dx;\n                case 'left':\n                    return -gestureState.dx;\n                default:\n                    return 0;\n            }\n        };\n        this.getSwipingDirection = (gestureState) => {\n            if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy)) {\n                return gestureState.dx > 0 ? 'right' : 'left';\n            }\n            return gestureState.dy > 0 ? 'down' : 'up';\n        };\n        this.calcDistancePercentage = (gestureState) => {\n            switch (this.currentSwipingDirection) {\n                case 'down':\n                    return ((gestureState.moveY - gestureState.y0) /\n                        ((this.props.deviceHeight || this.state.deviceHeight) -\n                            gestureState.y0));\n                case 'up':\n                    return reversePercentage(gestureState.moveY / gestureState.y0);\n                case 'left':\n                    return reversePercentage(gestureState.moveX / gestureState.x0);\n                case 'right':\n                    return ((gestureState.moveX - gestureState.x0) /\n                        ((this.props.deviceWidth || this.state.deviceWidth) - gestureState.x0));\n                default:\n                    return 0;\n            }\n        };\n        this.createAnimationEventForSwipe = () => {\n            if (this.currentSwipingDirection === 'right' ||\n                this.currentSwipingDirection === 'left') {\n                return Animated.event([null, { dx: this.state.pan.x }], {\n                    useNativeDriver: false,\n                });\n            }\n            else {\n                return Animated.event([null, { dy: this.state.pan.y }], {\n                    useNativeDriver: false,\n                });\n            }\n        };\n        this.isDirectionIncluded = (direction) => {\n            return Array.isArray(this.props.swipeDirection)\n                ? this.props.swipeDirection.includes(direction)\n                : this.props.swipeDirection === direction;\n        };\n        this.isSwipeDirectionAllowed = ({ dy, dx }) => {\n            const draggedDown = dy > 0;\n            const draggedUp = dy < 0;\n            const draggedLeft = dx < 0;\n            const draggedRight = dx > 0;\n            if (this.currentSwipingDirection === 'up' &&\n                this.isDirectionIncluded('up') &&\n                draggedUp) {\n                return true;\n            }\n            else if (this.currentSwipingDirection === 'down' &&\n                this.isDirectionIncluded('down') &&\n                draggedDown) {\n                return true;\n            }\n            else if (this.currentSwipingDirection === 'right' &&\n                this.isDirectionIncluded('right') &&\n                draggedRight) {\n                return true;\n            }\n            else if (this.currentSwipingDirection === 'left' &&\n                this.isDirectionIncluded('left') &&\n                draggedLeft) {\n                return true;\n            }\n            return false;\n        };\n        this.handleDimensionsUpdate = () => {\n            if (!this.props.deviceHeight && !this.props.deviceWidth) {\n                // Here we update the device dimensions in the state if the layout changed\n                // (triggering a render)\n                const deviceWidth = Dimensions.get('screen').width;\n                const deviceHeight = Dimensions.get('screen').height;\n                if (deviceWidth !== this.state.deviceWidth ||\n                    deviceHeight !== this.state.deviceHeight) {\n                    this.setState({ deviceWidth, deviceHeight });\n                }\n            }\n        };\n        this.open = () => {\n            if (this.isTransitioning) {\n                return;\n            }\n            this.isTransitioning = true;\n            if (this.backdropRef) {\n                this.backdropRef.transitionTo({ opacity: this.props.backdropOpacity }, this.props.backdropTransitionInTiming);\n            }\n            // This is for resetting the pan position,otherwise the modal gets stuck\n            // at the last released position when you try to open it.\n            // TODO: Could certainly be improved - no idea for the moment.\n            if (this.state.isSwipeable) {\n                this.state.pan.setValue({ x: 0, y: 0 });\n            }\n            if (this.contentRef) {\n                this.props.onModalWillShow && this.props.onModalWillShow();\n                this.contentRef\n                    .animate(this.animationIn, this.props.animationInTiming)\n                    .then(() => {\n                    this.isTransitioning = false;\n                    if (!this.props.isVisible) {\n                        this.close();\n                    }\n                    else {\n                        this.props.onModalShow();\n                    }\n                });\n            }\n        };\n        this.close = () => {\n            if (this.isTransitioning) {\n                return;\n            }\n            this.isTransitioning = true;\n            if (this.backdropRef) {\n                this.backdropRef.transitionTo({ opacity: 0 }, this.props.backdropTransitionOutTiming);\n            }\n            let animationOut = this.animationOut;\n            if (this.inSwipeClosingState) {\n                this.inSwipeClosingState = false;\n                if (this.currentSwipingDirection === 'up') {\n                    animationOut = 'slideOutUp';\n                }\n                else if (this.currentSwipingDirection === 'down') {\n                    animationOut = 'slideOutDown';\n                }\n                else if (this.currentSwipingDirection === 'right') {\n                    animationOut = 'slideOutRight';\n                }\n                else if (this.currentSwipingDirection === 'left') {\n                    animationOut = 'slideOutLeft';\n                }\n            }\n            if (this.contentRef) {\n                this.props.onModalWillHide && this.props.onModalWillHide();\n                this.contentRef\n                    .animate(animationOut, this.props.animationOutTiming)\n                    .then(() => {\n                    this.isTransitioning = false;\n                    if (this.props.isVisible) {\n                        this.open();\n                    }\n                    else {\n                        this.setState({\n                            showContent: false,\n                        }, () => {\n                            this.setState({\n                                isVisible: false,\n                            }, () => {\n                                this.props.onModalHide();\n                            });\n                        });\n                    }\n                });\n            }\n        };\n        const { animationIn, animationOut } = buildAnimations(extractAnimationFromProps(props));\n        this.animationIn = animationIn;\n        this.animationOut = animationOut;\n        if (this.state.isSwipeable) {\n            this.state = {\n                ...this.state,\n                pan: new Animated.ValueXY(),\n            };\n            this.buildPanResponder();\n        }\n        if (props.isVisible) {\n            this.state = {\n                ...this.state,\n                isVisible: true,\n                showContent: true,\n            };\n        }\n    }\n    static getDerivedStateFromProps(nextProps, state) {\n        if (!state.isVisible && nextProps.isVisible) {\n            return { isVisible: true, showContent: true };\n        }\n        return null;\n    }\n    componentDidMount() {\n        // Show deprecation message\n        if (this.props.onSwipe) {\n            console.warn('`<Modal onSwipe=\"...\" />` is deprecated and will be removed starting from 13.0.0. Use `<Modal onSwipeComplete=\"...\" />` instead.');\n        }\n        DeviceEventEmitter.addListener('didUpdateDimensions', this.handleDimensionsUpdate);\n        if (this.state.isVisible) {\n            this.open();\n        }\n    }\n    componentWillUnmount() {\n        DeviceEventEmitter.removeListener('didUpdateDimensions', this.handleDimensionsUpdate);\n    }\n    componentDidUpdate(prevProps) {\n        // If the animations have been changed then rebuild them to make sure we're\n        // using the most up-to-date ones\n        if (this.props.animationIn !== prevProps.animationIn ||\n            this.props.animationOut !== prevProps.animationOut) {\n            const { animationIn, animationOut } = buildAnimations(extractAnimationFromProps(this.props));\n            this.animationIn = animationIn;\n            this.animationOut = animationOut;\n        }\n        // If backdrop opacity has been changed then make sure to update it\n        if (this.props.backdropOpacity !== prevProps.backdropOpacity &&\n            this.backdropRef) {\n            this.backdropRef.transitionTo({ opacity: this.props.backdropOpacity }, this.props.backdropTransitionInTiming);\n        }\n        // On modal open request, we slide the view up and fade in the backdrop\n        if (this.props.isVisible && !prevProps.isVisible) {\n            this.open();\n        }\n        else if (!this.props.isVisible && prevProps.isVisible) {\n            // On modal close request, we slide the view down and fade out the backdrop\n            this.close();\n        }\n    }\n    render() {\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        const { animationIn, animationInTiming, animationOut, animationOutTiming, avoidKeyboard, coverScreen, hasBackdrop, backdropColor, backdropOpacity, backdropTransitionInTiming, backdropTransitionOutTiming, customBackdrop, children, deviceHeight: deviceHeightProp, deviceWidth: deviceWidthProp, isVisible, onModalShow, onBackdropPress, onBackButtonPress, useNativeDriver, propagateSwipe, style, ...otherProps } = this.props;\n        const deviceWidth = deviceWidthProp || this.state.deviceWidth;\n        const deviceHeight = deviceHeightProp || this.state.deviceHeight;\n        const computedStyle = [\n            { margin: deviceWidth * 0.05, transform: [{ translateY: 0 }] },\n            styles.content,\n            style,\n        ];\n        let panHandlers = {};\n        let panPosition = {};\n        if (this.state.isSwipeable) {\n            panHandlers = { ...this.panResponder.panHandlers };\n            if (useNativeDriver) {\n                panPosition = {\n                    transform: this.state.pan.getTranslateTransform(),\n                };\n            }\n            else {\n                panPosition = this.state.pan.getLayout();\n            }\n        }\n        const _children = this.props.hideModalContentWhileAnimating &&\n            this.props.useNativeDriver &&\n            !this.state.showContent ? (React.createElement(animatable.View, null)) : (children);\n        const containerView = (React.createElement(animatable.View, Object.assign({}, panHandlers, { ref: ref => (this.contentRef = ref), style: [panPosition, computedStyle], pointerEvents: \"box-none\", useNativeDriver: useNativeDriver }, otherProps), _children));\n        const hasCustomBackdrop = React.isValidElement(customBackdrop);\n        const backdropComputedStyle = [\n            {\n                width: deviceWidth,\n                height: deviceHeight,\n                backgroundColor: this.state.showContent && !hasCustomBackdrop\n                    ? backdropColor\n                    : 'transparent',\n            },\n        ];\n        const backdropContent = (React.createElement(animatable.View, { ref: ref => (this.backdropRef = ref), useNativeDriver: useNativeDriver, style: [styles.backdrop, backdropComputedStyle] }, hasCustomBackdrop && customBackdrop));\n        let backdrop = null;\n        if (hasCustomBackdrop) {\n            backdrop = backdropContent;\n        }\n        else {\n            // If there's no custom backdrop, handle presses with\n            // TouchableWithoutFeedback\n            backdrop = (React.createElement(TouchableWithoutFeedback, { onPress: onBackdropPress }, backdropContent));\n        }\n        if (!coverScreen && this.state.isVisible) {\n            return (React.createElement(View, { pointerEvents: \"box-none\", style: [styles.backdrop, styles.containerBox] },\n                hasBackdrop && backdrop,\n                containerView));\n        }\n        return (React.createElement(Modal, Object.assign({ transparent: true, animationType: 'none', visible: this.state.isVisible, onRequestClose: onBackButtonPress }, otherProps),\n            hasBackdrop && backdrop,\n            avoidKeyboard && (React.createElement(KeyboardAvoidingView, { behavior: Platform.OS === 'ios' ? 'padding' : undefined, pointerEvents: \"box-none\", style: computedStyle.concat([{ margin: 0 }]) }, containerView)),\n            !avoidKeyboard && containerView));\n    }\n}\nReactNativeModal.propTypes = {\n    animationIn: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n    animationInTiming: PropTypes.number,\n    animationOut: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n    animationOutTiming: PropTypes.number,\n    avoidKeyboard: PropTypes.bool,\n    coverScreen: PropTypes.bool,\n    hasBackdrop: PropTypes.bool,\n    backdropColor: PropTypes.string,\n    backdropOpacity: PropTypes.number,\n    backdropTransitionInTiming: PropTypes.number,\n    backdropTransitionOutTiming: PropTypes.number,\n    customBackdrop: PropTypes.node,\n    children: PropTypes.node.isRequired,\n    deviceHeight: PropTypes.number,\n    deviceWidth: PropTypes.number,\n    isVisible: PropTypes.bool.isRequired,\n    hideModalContentWhileAnimating: PropTypes.bool,\n    propagateSwipe: PropTypes.bool,\n    onModalShow: PropTypes.func,\n    onModalWillShow: PropTypes.func,\n    onModalHide: PropTypes.func,\n    onModalWillHide: PropTypes.func,\n    onBackButtonPress: PropTypes.func,\n    onBackdropPress: PropTypes.func,\n    onSwipeStart: PropTypes.func,\n    onSwipeMove: PropTypes.func,\n    onSwipeComplete: PropTypes.func,\n    onSwipeCancel: PropTypes.func,\n    swipeThreshold: PropTypes.number,\n    swipeDirection: PropTypes.oneOfType([\n        PropTypes.arrayOf(PropTypes.oneOf(['up', 'down', 'left', 'right'])),\n        PropTypes.oneOf(['up', 'down', 'left', 'right']),\n    ]),\n    useNativeDriver: PropTypes.bool,\n    style: PropTypes.any,\n    scrollTo: PropTypes.func,\n    scrollOffset: PropTypes.number,\n    scrollOffsetMax: PropTypes.number,\n    scrollHorizontal: PropTypes.bool,\n    supportedOrientations: PropTypes.arrayOf(PropTypes.oneOf([\n        'portrait',\n        'portrait-upside-down',\n        'landscape',\n        'landscape-left',\n        'landscape-right',\n    ])),\n};\nReactNativeModal.defaultProps = {\n    animationIn: 'slideInUp',\n    animationInTiming: 300,\n    animationOut: 'slideOutDown',\n    animationOutTiming: 300,\n    avoidKeyboard: false,\n    coverScreen: true,\n    hasBackdrop: true,\n    backdropColor: 'black',\n    backdropOpacity: 0.7,\n    backdropTransitionInTiming: 300,\n    backdropTransitionOutTiming: 300,\n    customBackdrop: null,\n    useNativeDriver: false,\n    deviceHeight: null,\n    deviceWidth: null,\n    hideModalContentWhileAnimating: false,\n    propagateSwipe: false,\n    isVisible: false,\n    onModalShow: () => null,\n    onModalWillShow: () => null,\n    onModalHide: () => null,\n    onModalWillHide: () => null,\n    onBackdropPress: () => null,\n    onBackButtonPress: () => null,\n    swipeThreshold: 100,\n    scrollTo: null,\n    scrollOffset: 0,\n    scrollOffsetMax: 0,\n    scrollHorizontal: false,\n    supportedOrientations: ['portrait', 'landscape'],\n};\nexport default ReactNativeModal;\n"]},"metadata":{},"sourceType":"module"}